Top 10 Machine Learning Algorithms in 2025 - Analytics Vidhya Master Generative AI with 10+ Real-world Projects in 2025! d : h : m : s Download Projects Free Courses Learning Paths GenAI Pinnacle Plus New Agentic AI Pioneer DHS 2025 Login Switch Mode Logout Interview PrepCareerGenAIPrompt EnggChatGPTLLMLangchainRAGAI AgentsMachine LearningDeep LearningGenAI ToolsLLMOpsPythonNLPSQLAIML Projects Reading list Basics of Machine LearningMachine Learning Basics for a Newbie Machine Learning Lifecycle6 Steps of Machine learning LifecycleIntroduction to Predictive Modeling Importance of Stats and EDAIntroduction to Exploratory Data Analysis & Data InsightsDescriptive StatisticsInferential StatisticsHow to Understand Population Distributions? Understanding DataReading Data Files into PythonDifferent Variable Datatypes ProbabilityProbability for Data ScienceBasic Concepts of ProbabilityAxioms of ProbabilityConditional Probability Exploring Continuous VariableCentral Tendencies for Continuous VariablesSpread of DataKDE plots for Continuous VariableOverview of Distribution for Continuous variablesNormal DistributionSkewed DistributionSkeweness and KurtosisDistribution for Continuous Variable Exploring Categorical VariablesCentral Tendencies for Categorical VariablesUnderstanding Discrete DistributionsPerforming EDA on Categorical Variables Missing Values and OutliersDealing with Missing ValuesUnderstanding OutliersIdentifying Outliers in DataOutlier Detection in PythonOutliers Detection Using IQR, Z-score, LOF and DBSCAN Central Limit theoremSample and PopulationCentral Limit TheoremConfidence Interval and Margin of Error Bivariate Analysis IntroductionBivariate Analysis Introduction Continuous - Continuous VariablesCovariancePearson CorrelationSpearman's Correlation & Kendall's TauCorrelation versus CausationTabular and Graphical methods for Bivariate AnalysisPerforming Bivariate Analysis on Continuous-Continuous Variables Continuous CategoricalTabular and Graphical methods for Continuous-Categorical VariablesIntroduction to Hypothesis TestingP-valueTwo sample Z-testT-testT-test vs Z-testPerforming Bivariate Analysis on Continuous-Catagorical variables Categorical CategoricalChi-Squares TestBivariate Analysis on Categorical Categorical Variables Multivariate AnalysisMultivariate AnalysisA Comprehensive Guide to Data ExplorationThe Data Science behind IPL Different tasks in Machine LearningSupervised Learning vs Unsupervised LearningReinforcement LearningGenerative and Descriminative ModelsParametric and Non Parametric model Build Your First Predictive ModelMachine Learning PipelinePreparing DatasetBuild a Benchmark Model: RegressionBuild a Benchmark Model: Classification Evaluation MetricsEvaluation Metrics for Machine Learning Everyone should knowConfusion MatrixAccuracyPrecision and RecallAUC-ROCLog LossR2 and Adjusted R2 Preprocessing DataDealing with Missing ValuesReplacing Missing ValuesImputing Missing Values in DataWorking with Categorical VariablesWorking with OutliersPreprocessing Data for Model Building Linear ModelsUnderstanding Cost FunctionUnderstanding Gradient DescentMath Behind Gradient DescentAssumptions of Linear RegressionImplement Linear Regression from ScratchTrain Linear Regression in PythonImplementing Linear Regression in RDiagnosing Residual Plots in Linear Regression ModelsGeneralized Linear ModelsIntroduction to Logistic RegressionOdds RatioImplementing Logistic Regression from ScratchIntroduction to Scikit-learn in PythonTrain Logistic Regression in pythonMulticlass using Logistic RegressionHow to use Multinomial and Ordinal Logistic Regression in R ?Challenges with Linear RegressionIntroduction to RegularisationImplementing RegularisationRidge RegressionLasso Regression KNNIntroduction to K Nearest NeighboursDetermining the Right Value of K in KNNImplement KNN from ScratchImplement KNN in Python Selecting the Right ModelBias Variance TradeoffIntroduction to Overfitting and UnderfittingVisualizing Overfitting and UnderfittingSelecting the Right ModelWhat is Validation?Hold-Out ValidationUnderstanding K Fold Cross Validation Feature Selection TechniquesIntroduction to Feature SelectionFeature Selection AlgorithmsMissing Value RatioLow Variance FilterHigh Correlation FilterBackward Feature EliminationForward Feature SelectionImplement Feature Selection in PythonImplement Feature Selection in R Decision TreeIntroduction to Decision TreePurity in Decision TreeTerminologies Related to Decision TreeHow to Select Best Split Point in Decision Tree?Chi-SquaresInformation GainReduction in VarianceOptimizing Performance of Decision TreeTrain Decision Tree using Scikit LearnPruning of Decision Trees Feature EngineeringIntroduction to Feature EngineeringFeature TransformationFeature ScalingFeature EngineeringFrequency EncodingAutomated Feature Engineering: Feature Tools Naive BayesIntroduction to Naive BayesConditional Probability and Bayes TheoremIntroduction to Bayesian Adjustment Rating: The Incredible Concept Behind Online Ratings!Working of Naive BayesMath behind Naive BayesTypes of Naive BayesImplementation of Naive Bayes Multiclass and MultilabelUnderstanding how to solve Multiclass and Multilabled Classification ProblemEvaluation Metrics: Multi Class Classification Basics of Ensemble TechniquesIntroduction to Ensemble TechniquesBasic Ensemble TechniquesImplementing Basic Ensemble TechniquesFinding Optimal Weights of Ensemble Learner using Neural NetworkWhy Ensemble Models Work well? Advance Ensemble TechniquesIntroduction to StackingImplementing StackingVariants of StackingImplementing Variants of StackingIntroduction to BlendingBootstrap SamplingIntroduction to Random SamplingHyper-parameters of Random ForestImplementing Random ForestOut-of-Bag (OOB) Score in the Random ForestIPL Team Win Prediction Project Using Machine LearningIntroduction to BoostingGradient Boosting AlgorithmMath behind GBMImplementing GBM in pythonRegularized Greedy ForestsExtreme Gradient BoostingImplementing XGBM in pythonTuning Hyperparameters of XGBoost in PythonImplement XGBM in R/H2OAdaptive BoostingImplementing Adaptive BoosingLightGBMImplementing LightGBM in PythonCatboostImplementing Catboost in Python Hyperparameter TuningDifferent Hyperparameter Tuning methodsImplementing Different Hyperparameter Tuning methodsGridsearchCVRandomizedsearchCVBayesian Optimization for Hyperparameter TuningHyperopt Support Vector MachineUnderstanding SVM AlgorithmSVM Kernels In-depth Intuition and Practical ImplementationSVM Kernel TricksKernels and Hyperparameters in SVMImplementing SVM from Scratch in Python and R Advance Dimensionality ReductionIntroduction to Principal Component AnalysisSteps to Perform Principal Compound AnalysisComputation of Covariance MatrixFinding Eigenvectors and EigenvaluesImplementing PCA in pythonVisualizing PCAA Brief Introduction to Linear Discriminant AnalysisIntroduction to Factor Analysis Unsupervised Machine Learning MethodsIntroduction to ClusteringApplications of ClusteringEvaluation Metrics for ClusteringUnderstanding K-MeansImplementation of K-Means in PythonImplementation of K-Means in RChoosing Right Value for KProfiling Market Segments using K-Means ClusteringHierarchical ClusteringImplementation of Hierarchial ClusteringDBSCANDefining Similarity between clustersBuild Better and Accurate Clusters with Gaussian Mixture Models Recommendation EnginesUnderstand Basics of Recommendation Engine with Case Study Improving ML models8 Ways to Improve Accuracy of Machine Learning Models Working with Large DatasetsIntroduction to DaskWorking with CuML Interpretability of Machine Learning ModelsIntroduction to Machine Learning InterpretabilityFramework and Interpretable Modelsmodel Agnostic Methods for InterpretabilityImplementing Interpretable ModelUnderstanding SHAPOut-of-Core MLIntroduction to Interpretable Machine Learning ModelsModel Agnostic Methods for InterpretabilityGame Theory & Shapley Values Automated Machine LearningIntroduction to AutoMLImplementation of MLBoxIntroduction to PyCaretTPOTAuto-SklearnEvalML Model DeploymentPickle and JoblibIntroduction to Model Deployment Deploying ML ModelsDeploying Machine Learning Model using StreamlitDeploying ML Models in DockerDeploy Using StreamlitDeploy on HerokuDeploy Using NetlifyIntroduction to Amazon SagemakerSetting up Amazon SageMakerUsing SageMaker Endpoint to Generate InferenceDeploy on Microsoft Azure CloudIntroduction to Flask for ModelDeploying ML model using Flask Embedded DevicesModel Deployment in AndroidModel Deployment in Iphone Home Machine Learning Top 10 Machine Learning Algorithms in 2025 Top 10 Machine Learning Algorithms in 2025 Sunil Ray Last Updated : 28 Apr, 2025 25 min read We are probably living in the most defining period of human history. The period when computing moved from large mainframes to PCs to the cloud. But what makes it defining is not what has happened but what is coming our way in years to come. What makes this period exciting and enthralling for someone like me is the democratization of the various tools, techniques, and machine learning algorithms that followed the boost in computing. Welcome to the world of Data Science! In this article you will get to know about the 10 machine learning algorithms and how these algorihtms solved the data problems with aspects and real-world examples. Today, as a data scientist, I can build data-crunching machines with complex algorithms for a few dollars per hour. But reaching here wasn’t easy! I had my dark days and nights. Table of contentsTypes of Machine Learning AlgorithmsSupervised LearningUnsupervised LearningReinforcement LearningList of Top 10 Common Machine Learning Algorithms1. Linear Regression2. Logistic Regression3. Decision Tree4. SVM (Support Vector Machine)5. Naive Bayes6. kNN (k- Nearest Neighbors)7. K-Means8. Random Forest9. Dimensionality Reduction Algorithms10. Gradient Boosting AlgorithmsPractice ProblemsConclusionFrequently Asked Questions Types of Machine Learning Algorithms Supervised Learning This  algorithm learns from labeled data. It’s like a teacher giving examples with answers. After training, it can predict outcomes for new data. Common uses include spam detection and weather forecasting. Unsupervised Learning The Unsupervised algorithm finds patterns or groups on its own. Think of it as sorting a messy closet without instructions. It’s useful for customer segmentation or spotting anomalies. Reinforcement Learning The Reinforcement Learning Model mainly learns by trial and error, getting rewards for good decisions and penalties for bad ones—like training a pet with treats. Also Read: Everything You Need to Know about Machine Learning List of Top 10 Common Machine Learning Algorithms Here is the list of commonly used machine learning algorithms. These algorithms can be applied to almost any data problem: 1. Linear Regression It is used to estimate real values (cost of houses, number of calls, total sales, etc.) based on a continuous variable(s). Here, we establish the relationship between independent and dependent variables by fitting the best line. This best-fit line is known as the regression line and is represented by a linear equation Y= a*X + b. Example 1 The best way to understand linear regression is to relive this experience of childhood. Let us say you ask a child in fifth grade to arrange people in his class by increasing the order of weight without asking them their weights! What do you think the child will do? They would likely look (visually analyze) at the height and build of people and arrange them using a combination of these visible parameters. This is linear regression in real life! The child has actually figured out that height and build would be correlated to weight by a relationship, which looks like the equation above. In this equation: Y – Dependent Variable a – Slope X – Independent variable b – Intercept These coefficients a and b are derived based on minimizing the sum of the squared difference of distance between data points and the regression line. Example 2 Look at the below example. Here we have identified the best-fit line having linear equation y=0.2811x+13.9. Now using this equation, we can find the weight, knowing the height of a person. Linear Regression is mainly of two types: Simple Linear Regression and Multiple Linear Regression. Simple Linear Regression is characterized by one independent variable. And, Multiple Linear Regression(as the name suggests) is characterized by multiple (more than 1) independent variables. While finding the best-fit line, you can fit a polynomial or curvilinear regression. And these are known as polynomial or curvilinear regression. Here’s a coding window to try out your hand and build your own linear Regression Model: Python # importing required libraries import pandas as pd from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error # read the train and test dataset train_data = pd.read_csv('train.csv') test_data = pd.read_csv('test.csv') print(train_data.head()) # shape of the dataset print('\nShape of training data :',train_data.shape) print('\nShape of testing data :',test_data.shape) # Now, we need to predict the missing target variable in the test data # target variable - Item_Outlet_Sales # seperate the independent and target variable on training data train_x = train_data.drop(columns=['Item_Outlet_Sales'],axis=1) train_y = train_data['Item_Outlet_Sales'] # seperate the independent and target variable on training data test_x = test_data.drop(columns=['Item_Outlet_Sales'],axis=1) test_y = test_data['Item_Outlet_Sales'] ''' Create the object of the Linear Regression model You can also add other parameters and test your code here Some parameters are : fit_intercept and normalize Documentation of sklearn LinearRegression: https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html ''' model = LinearRegression() # fit the model with the training data model.fit(train_x,train_y) # coefficeints of the trained model print('\nCoefficient of model :', model.coef_) # intercept of the model print('\nIntercept of model',model.intercept_) # predict the target on the test dataset predict_train = model.predict(train_x) print('\nItem_Outlet_Sales on training data',predict_train) # Root Mean Squared Error on training dataset rmse_train = mean_squared_error(train_y,predict_train)**(0.5) print('\nRMSE on train dataset : ', rmse_train) # predict the target on the testing dataset predict_test = model.predict(test_x) print('\nItem_Outlet_Sales on test data',predict_test) # Root Mean Squared Error on testing dataset rmse_test = mean_squared_error(test_y,predict_test)**(0.5) print('\nRMSE on test dataset : ', rmse_test) R Code: #Load Train and Test datasets #Identify feature and response variable(s) and values must be numeric and numpy arrays x_train <- input_variables_values_training_datasets y_train <- target_variables_values_training_datasets x_test <- input_variables_values_test_datasets x <- cbind(x_train,y_train) # Train the model using the training sets and check score linear <- lm(y_train ~ ., data = x) summary(linear) #Predict Output predicted= predict(linear,x_test) 2. Logistic Regression Don’t get confused by its name! It is a classification algorithm, not a regression algorithm. It is used to estimate discrete values ( Binary values like 0/1, yes/no, true/false ) based on a given set of independent variable(s). In simple words, it predicts the probability of the occurrence of an event by fitting data to a logistic function. Hence, it is also known as logit regression. Since it predicts the probability, its output values lie between 0 and 1 (as expected). Again, let us try and understand this through a simple example. Let’s say your friend gives you a puzzle to solve. There are only 2 outcome scenarios – either you solve it, or you don’t. Now imagine that you are being given a wide range of puzzles/quizzes in an attempt to understand which subjects you are good at. The outcome of this study would be something like this – if you are given a trigonometry-based tenth-grade problem, you are 70% likely to solve it. On the other hand, if it is a grade fifth history question, the probability of getting an answer is only 30%. This is what Logistic Regression provides you. Coming to the math, the log odds of the outcome are modeled as a linear combination of the predictor variables. odds= p/ (1-p) = probability of event occurrence / probability of not event occurrence ln(odds) = ln(p/(1-p)) logit(p) = ln(p/(1-p)) = b0+b1X1+b2X2+b3X3....+bkXk Above, p is the probability of the presence of the characteristic of interest. It chooses parameters that maximize the likelihood of observing the sample values rather than that minimize the sum of squared errors (like in ordinary regression). Now, you may ask, why take a log? For the sake of simplicity, let’s just say that this is one of the best mathematical ways to replicate a step function. I can go into more details, but that will beat the purpose of this article. Build your own logistic regression model in Python here and check the accuracy: # importing required libraries import pandas as pd from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score # read the train and test dataset train_data = pd.read_csv('train-data.csv') test_data = pd.read_csv('test-data.csv') print(train_data.head()) # shape of the dataset print('Shape of training data :',train_data.shape) print('Shape of testing data :',test_data.shape) # Now, we need to predict the missing target variable in the test data # target variable - Survived # seperate the independent and target variable on training data train_x = train_data.drop(columns=['Survived'],axis=1) train_y = train_data['Survived'] # seperate the independent and target variable on testing data test_x = test_data.drop(columns=['Survived'],axis=1) test_y = test_data['Survived'] ''' Create the object of the Logistic Regression model You can also add other parameters and test your code here Some parameters are : fit_intercept and penalty Documentation of sklearn LogisticRegression: https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html ''' model = LogisticRegression() # fit the model with the training data model.fit(train_x,train_y) # coefficeints of the trained model print('Coefficient of model :', model.coef_) # intercept of the model print('Intercept of model',model.intercept_) # predict the target on the train dataset predict_train = model.predict(train_x) print('Target on train data',predict_train) # Accuray Score on train dataset accuracy_train = accuracy_score(train_y,predict_train) print('accuracy_score on train dataset : ', accuracy_train) # predict the target on the test dataset predict_test = model.predict(test_x) print('Target on test data',predict_test) # Accuracy Score on test dataset accuracy_test = accuracy_score(test_y,predict_test) print('accuracy_score on test dataset : ', accuracy_test) R Code: x <- cbind(x_train,y_train) # Train the model using the training sets and check score logistic <- glm(y_train ~ ., data = x,family='binomial') summary(logistic) #Predict Output predicted= predict(logistic,x_test) Furthermore… There are many different steps that could be tried in order to improve the model: including interaction terms removing features regularization techniques using a non-linear model 3. Decision Tree This is one of my favorite algorithms, and I use it quite frequently. It is a type of supervised learning algorithm that is mostly used for classification problems. Surprisingly, it works for both categorical and continuous dependent variables. In this algorithm, we split the population into two or more homogeneous sets. This is done based on the most significant attributes/ independent variables to make as distinct groups as possible. For more details, you can read Decision Tree Simplified. In the image above, you can see that population is classified into four different groups based on multiple attributes to identify ‘if they will play or not’. To split the population into different heterogeneous groups, it uses various techniques like Gini, Information Gain, Chi-square, and entropy. The best way to understand how the decision tree works, is to play Jezzball – a classic game from Microsoft (image below). Essentially, you have a room with moving walls and you need to create walls such that the maximum area gets cleared off without the balls. So, every time you split the room with a wall, you are trying to create 2 different populations within the same room. Decision trees work in a very similar fashion by dividing a population into as different groups as possible. Read More: Simplified Version of Decision Tree Algorithms Let’s get our hands dirty and code our own decision tree in Python! # importing required libraries import pandas as pd from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score # read the train and test dataset train_data = pd.read_csv('train-data.csv') test_data = pd.read_csv('test-data.csv') # shape of the dataset print('Shape of training data :',train_data.shape) print('Shape of testing data :',test_data.shape) # Now, we need to predict the missing target variable in the test data # target variable - Survived # seperate the independent and target variable on training data train_x = train_data.drop(columns=['Survived'],axis=1) train_y = train_data['Survived'] # seperate the independent and target variable on testing data test_x = test_data.drop(columns=['Survived'],axis=1) test_y = test_data['Survived'] ''' Create the object of the Decision Tree model You can also add other parameters and test your code here Some parameters are : max_depth and max_features Documentation of sklearn DecisionTreeClassifier: https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html ''' model = DecisionTreeClassifier() # fit the model with the training data model.fit(train_x,train_y) # depth of the decision tree print('Depth of the Decision Tree :', model.get_depth()) # predict the target on the train dataset predict_train = model.predict(train_x) print('Target on train data',predict_train) # Accuray Score on train dataset accuracy_train = accuracy_score(train_y,predict_train) print('accuracy_score on train dataset : ', accuracy_train) # predict the target on the test dataset predict_test = model.predict(test_x) print('Target on test data',predict_test) # Accuracy Score on test dataset accuracy_test = accuracy_score(test_y,predict_test) print('accuracy_score on test dataset : ', accuracy_test) R Code: library(rpart) x <- cbind(x_train,y_train) # grow tree fit <- rpart(y_train ~ ., data = x,method="class") summary(fit) #Predict Output predicted= predict(fit,x_test) 4. SVM (Support Vector Machine) It is a classification method. In SVM algorithm, we plot each data item as a point in n-dimensional space (where n is the number of features you have), with the value of each feature being the value of a particular coordinate. For example, if we only had two features like the Height and Hair length of an individual, we’d first plot these two variables in two-dimensional space where each point has two coordinates (these co-ordinates are known as Support Vectors) Now, we will find some lines that split the data between the two differently classified groups of data. This will be the line such that the distances from the closest point in each of the two groups will be the farthest away. If there are more variables, a hyperplane is used to separate the classes. In the example shown above, the line which splits the data into two differently classified groups is the black line since the two closest points are the farthest apart from the line. This line is our classifier. Then, depending on where the testing data lands on either side of the line, that’s what class we can classify the new data as. Think of this algorithm as playing JezzBall in n-dimensional space. The tweaks in the game are: You can draw lines/planes at any angle (rather than just horizontal or vertical as in the classic game) The objective of the game is to segregate balls of different colors in different rooms. And the balls are not moving. Try your hand and design an SVM model in Python through this coding window: # importing required libraries import pandas as pd from sklearn.svm import SVC from sklearn.metrics import accuracy_score # read the train and test dataset train_data = pd.read_csv('train-data.csv') test_data = pd.read_csv('test-data.csv') # shape of the dataset print('Shape of training data :',train_data.shape) print('Shape of testing data :',test_data.shape) # Now, we need to predict the missing target variable in the test data # target variable - Survived # seperate the independent and target variable on training data train_x = train_data.drop(columns=['Survived'],axis=1) train_y = train_data['Survived'] # seperate the independent and target variable on testing data test_x = test_data.drop(columns=['Survived'],axis=1) test_y = test_data['Survived'] ''' Create the object of the Support Vector Classifier model You can also add other parameters and test your code here Some parameters are : kernal and degree Documentation of sklearn Support Vector Classifier: https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html ''' model = SVC() # fit the model with the training data model.fit(train_x,train_y) # predict the target on the train dataset predict_train = model.predict(train_x) print('Target on train data',predict_train) # Accuray Score on train dataset accuracy_train = accuracy_score(train_y,predict_train) print('accuracy_score on train dataset : ', accuracy_train) # predict the target on the test dataset predict_test = model.predict(test_x) print('Target on test data',predict_test) # Accuracy Score on test dataset accuracy_test = accuracy_score(test_y,predict_test) print('accuracy_score on test dataset : ', accuracy_test) R Code: library(e1071) x <- cbind(x_train,y_train) # Fitting model fit <-svm(y_train ~ ., data = x) summary(fit) #Predict Output predicted= predict(fit,x_test) 5. Naive Bayes Naive Bayes is a classification technique based on Bayes’ theorem with an assumption of independence between predictors. In simple terms, a Naive Bayes classifier assumes that the presence of a particular feature in a class is unrelated to the presence of any other feature. For example, a fruit may be considered to be an apple if it is red, round, and about 3 inches in diameter. Even if these features depend on each other, a Naive Bayes algorithm for classification would treat each property as independently contributing to the probability that this fruit is an apple. The Naive Bayesian model is easy to build and particularly useful for very large data sets. Along with simplicity, Naive Bayes classification is known to outperform even highly sophisticated methods for tasks such as text classification, spam detection, and sentiment analysis. Naive Bayes Equation Bayes theorem provides a way of calculating posterior probability P(c|x) from P(c), P(x), and P(x|c). Look at the equation below: Here, P(c|x) is the posterior probability of class (target) given predictor (attribute). P(c) is the prior probability of the class. P(x|c) is the likelihood which is the probability of the predictor given the class. P(x) is the prior probability of the predictor. Example Let’s understand it using an example. Below is a training data set of weather and the corresponding target variable, ‘Play.’ Now, we need to classify whether players will play or not based on weather conditions. Let’s follow the below steps to perform it. Time needed: 3 minutes Convert the data set to a frequency table. Create a Likelihood table by finding the probabilities like Overcast probability = 0.29 and probability of playing is 0.64. Now, use the Naive Bayesian equation to calculate the posterior probability for each class. The class with the highest posterior probability is the outcome of the prediction. Problem: Players will pay if the weather is sunny. Is this statement correct? We can solve it using above discussed method, so P(Yes | Sunny) = P( Sunny | Yes) * P(Yes) / P (Sunny) Here we have P (Sunny | Yes) = 3/9 = 0.33, P(Sunny) = 5/14 = 0.36, P(Yes)= 9/14 = 0.64 Now, P (Yes | Sunny) = 0.33 * 0.64 / 0.36 = 0.60, which has a higher probability. Naive Bayes uses a similar method to predict the probability of different classes based on various attributes. This algorithm is mostly used in text classification and with problems having multiple classes. Code for a Naive Bayes classification model in Python: # importing required libraries import pandas as pd from sklearn.naive_bayes import GaussianNB from sklearn.metrics import accuracy_score # read the train and test dataset train_data = pd.read_csv('train-data.csv') test_data = pd.read_csv('test-data.csv') # shape of the dataset print('Shape of training data :',train_data.shape) print('Shape of testing data :',test_data.shape) # Now, we need to predict the missing target variable in the test data # target variable - Survived # seperate the independent and target variable on training data train_x = train_data.drop(columns=['Survived'],axis=1) train_y = train_data['Survived'] # seperate the independent and target variable on testing data test_x = test_data.drop(columns=['Survived'],axis=1) test_y = test_data['Survived'] ''' Create the object of the Naive Bayes model You can also add other parameters and test your code here Some parameters are : var_smoothing Documentation of sklearn GaussianNB: https://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.GaussianNB.html ''' model = GaussianNB() # fit the model with the training data model.fit(train_x,train_y) # predict the target on the train dataset predict_train = model.predict(train_x) print('Target on train data',predict_train) # Accuray Score on train dataset accuracy_train = accuracy_score(train_y,predict_train) print('accuracy_score on train dataset : ', accuracy_train) # predict the target on the test dataset predict_test = model.predict(test_x) print('Target on test data',predict_test) # Accuracy Score on test dataset accuracy_test = accuracy_score(test_y,predict_test) print('accuracy_score on test dataset : ', accuracy_test) R Code: library(e1071) x <- cbind(x_train,y_train) # Fitting model fit <-naiveBayes(y_train ~ ., data = x) summary(fit) #Predict Output predicted= predict(fit,x_test) 6. kNN (k- Nearest Neighbors) KNN can be used for both classification and regression problems. However, it is more widely employed as a classification algorithm in machine learning. K-Nearest Neighbors is a simple, intuitive algorithm that stores all available cases and classifies new cases by a majority vote of its k nearest neighbors. The class assigned to a new case is the one most common among its K nearest neighbors as measured by a distance function. The distance functions used in KNN can be Euclidean, Manhattan, Minkowski, or Hamming distances. The first three are typically used for continuous variables, while Hamming distance is applied for categorical variables. If K = 1, the case is simply assigned to the class of its nearest neighbor. However, choosing the right value of K can be challenging and often depends on the dataset being used in KNN modeling. In real-life scenarios, KNN can be likened to discovering more about a person based on their close friends or social circles. If you know nothing about someone, their neighbors’ characteristics can offer insights. Key Considerations for KNN KNN is computationally expensive as it stores all available data. Feature scaling is essential—variables should be normalized, as higher range variables can bias the results. Pre-processing steps such as outlier removal and noise reduction significantly impact the performance of KNN models. Python Code: # importing required libraries import pandas as pd from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score # read the train and test dataset train_data = pd.read_csv('train-data.csv') test_data = pd.read_csv('test-data.csv') # shape of the dataset print('Shape of training data :',train_data.shape) print('Shape of testing data :',test_data.shape) # Now, we need to predict the missing target variable in the test data # target variable - Survived # seperate the independent and target variable on training data train_x = train_data.drop(columns=['Survived'],axis=1) train_y = train_data['Survived'] # seperate the independent and target variable on testing data test_x = test_data.drop(columns=['Survived'],axis=1) test_y = test_data['Survived'] ''' Create the object of the K-Nearest Neighbor model You can also add other parameters and test your code here Some parameters are : n_neighbors, leaf_size Documentation of sklearn K-Neighbors Classifier: https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html ''' model = KNeighborsClassifier() # fit the model with the training data model.fit(train_x,train_y) # Number of Neighbors used to predict the target print('\nThe number of neighbors used to predict the target : ',model.n_neighbors) # predict the target on the train dataset predict_train = model.predict(train_x) print('\nTarget on train data',predict_train) # Accuray Score on train dataset accuracy_train = accuracy_score(train_y,predict_train) print('accuracy_score on train dataset : ', accuracy_train) # predict the target on the test dataset predict_test = model.predict(test_x) print('Target on test data',predict_test) # Accuracy Score on test dataset accuracy_test = accuracy_score(test_y,predict_test) print('accuracy_score on test dataset : ', accuracy_test) R Code: library(knn) x <- cbind(x_train,y_train) # Fitting model fit <-knn(y_train ~ ., data = x,k=5) summary(fit) #Predict Output predicted= predict(fit,x_test) Also Read: Everything You Need to Know about Machine Learning 7. K-Means It is a type of unsupervised algorithm which solves the clustering problem. Its procedure follows a simple and easy way to classify a given data set through a certain number of clusters (assume k clusters). Data points inside a cluster are homogeneous and heterogeneous to peer groups. Remember figuring out shapes from ink blots? k means is somewhat similar to this activity. You look at the shape and spread to decipher how many different clusters/populations are present! How K-means forms cluster: K-means picks k number of points for each cluster known as centroids. Each data point forms a cluster with the closest centroids, i.e., k clusters. Finds the centroid of each cluster based on existing cluster members. Here we have new centroids. As we have new centroids, repeat steps 2 and 3. Find the closest distance for each data point from new centroids and get associated with new k-clusters. Repeat this process until convergence occurs, i.e., centroids do not change. How to determine the value of K: In K-means, we have clusters, and each cluster has its own centroid. The sum of the square of the difference between the centroid and the data points within a cluster constitutes the sum of the square value for that cluster. Also, when the sum of square values for all the clusters is added, it becomes a total within the sum of the square value for the cluster solution. We know that as the number of clusters increases, this value keeps on decreasing, but if you plot the result, you may see that the sum of squared distance decreases sharply up to some value of k and then much more slowly after that. Here, we can find the optimum number of clusters. Python Code: # importing required libraries import pandas as pd from sklearn.cluster import KMeans # read the train and test dataset train_data = pd.read_csv('train-data.csv') test_data = pd.read_csv('test-data.csv') # shape of the dataset print('Shape of training data :',train_data.shape) print('Shape of testing data :',test_data.shape) # Now, we need to divide the training data into differernt clusters # and predict in which cluster a particular data point belongs. ''' Create the object of the K-Means model You can also add other parameters and test your code here Some parameters are : n_clusters and max_iter Documentation of sklearn KMeans: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html ''' model = KMeans() # fit the model with the training data model.fit(train_data) # Number of Clusters print('\nDefault number of Clusters : ',model.n_clusters) # predict the clusters on the train dataset predict_train = model.predict(train_data) print('\nCLusters on train data',predict_train) # predict the target on the test dataset predict_test = model.predict(test_data) print('Clusters on test data',predict_test) # Now, we will train a model with n_cluster = 3 model_n3 = KMeans(n_clusters=3) # fit the model with the training data model_n3.fit(train_data) # Number of Clusters print('\nNumber of Clusters : ',model_n3.n_clusters) # predict the clusters on the train dataset predict_train_3 = model_n3.predict(train_data) print('\nCLusters on train data',predict_train_3) # predict the target on the test dataset predict_test_3 = model_n3.predict(test_data) print('Clusters on test data',predict_test_3) R Code: library(cluster) fit <- kmeans(X, 3) # 5 cluster solution 8. Random Forest Random Forest is a trademarked term for an ensemble learning of decision trees. In Random Forest, we’ve got a collection of decision trees (also known as “Forest”). To classify a new object based on attributes, each tree gives a classification, and we say the tree “votes” for that class. The forest chooses the classification having the most votes (over all the trees in the forest). Each tree is planted & grown as follows: If the number of cases in the training set is N, then a sample of N cases is taken at random but with replacement. This sample will be the training set for growing the tree. If there are M input variables, a number m<<M is specified such that at each node, m variables are selected at random out of the M, and the best split on this m is used to split the node. The value of m is held constant during the forest growth. Each tree is grown to the largest extent possible. There is no pruning. For more details on this algorithm, compared with the decision tree and tuning model parameters, I would suggest you read these articles: Introduction to Random forest – Simplified Comparing a CART model to Random Forest (Part 1) Comparing a Random Forest to a CART model (Part 2) Tuning the parameters of your Random Forest model Python Code: # importing required libraries import pandas as pd from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score # read the train and test dataset train_data = pd.read_csv('train-data.csv') test_data = pd.read_csv('test-data.csv') # view the top 3 rows of the dataset print(train_data.head(3)) # shape of the dataset print('\nShape of training data :',train_data.shape) print('\nShape of testing data :',test_data.shape) # Now, we need to predict the missing target variable in the test data # target variable - Survived # seperate the independent and target variable on training data train_x = train_data.drop(columns=['Survived'],axis=1) train_y = train_data['Survived'] # seperate the independent and target variable on testing data test_x = test_data.drop(columns=['Survived'],axis=1) test_y = test_data['Survived'] ''' Create the object of the Random Forest model You can also add other parameters and test your code here Some parameters are : n_estimators and max_depth Documentation of sklearn RandomForestClassifier: https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html ''' model = RandomForestClassifier() # fit the model with the training data model.fit(train_x,train_y) # number of trees used print('Number of Trees used : ', model.n_estimators) # predict the target on the train dataset predict_train = model.predict(train_x) print('\nTarget on train data',predict_train) # Accuray Score on train dataset accuracy_train = accuracy_score(train_y,predict_train) print('\naccuracy_score on train dataset : ', accuracy_train) # predict the target on the test dataset predict_test = model.predict(test_x) print('\nTarget on test data',predict_test) # Accuracy Score on test dataset accuracy_test = accuracy_score(test_y,predict_test) print('\naccuracy_score on test dataset : ', accuracy_test) R Code: library(randomForest) x <- cbind(x_train,y_train) # Fitting model fit <- randomForest(Species ~ ., x,ntree=500) summary(fit) #Predict Output predicted= predict(fit,x_test) 9. Dimensionality Reduction Algorithms In the last 4-5 years, there has been an exponential increase in data capturing at every possible stage. Corporates/ Government Agencies/ Research organizations are not only coming up with new sources, but also they are capturing data in great detail. For example, E-commerce companies are capturing more details about customers like their demographics, web crawling history, what they like or dislike, purchase history, feedback, and many others to give them personalized attention more than your nearest grocery shopkeeper. As data scientists, the data we are offered also consists of many features, this sounds good for building a good robust model, but there is a challenge. How’d you identify highly significant variable(s) out of 1000 or 2000? In such cases, the dimensionality reduction algorithm helps us, along with various other algorithms like Decision Tree, Random Forest, PCA (principal component analysis), Factor Analysis, Identity-based on the correlation matrix, missing value ratio, and others. To know more about these algorithms, you can read “Beginners Guide To Learn Dimension Reduction Techniques“. Python Code: # importing required libraries import pandas as pd from sklearn.decomposition import PCA from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error # read the train and test dataset train_data = pd.read_csv('train.csv') test_data = pd.read_csv('test.csv') # view the top 3 rows of the dataset print(train_data.head(3)) # shape of the dataset print('\nShape of training data :',train_data.shape) print('\nShape of testing data :',test_data.shape) # Now, we need to predict the missing target variable in the test data # target variable - Survived # seperate the independent and target variable on training data # target variable - Item_Outlet_Sales train_x = train_data.drop(columns=['Item_Outlet_Sales'],axis=1) train_y = train_data['Item_Outlet_Sales'] # seperate the independent and target variable on testing data test_x = test_data.drop(columns=['Item_Outlet_Sales'],axis=1) test_y = test_data['Item_Outlet_Sales'] print('\nTraining model with {} dimensions.'.format(train_x.shape[1])) # create object of model model = LinearRegression() # fit the model with the training data model.fit(train_x,train_y) # predict the target on the train dataset predict_train = model.predict(train_x) # Accuray Score on train dataset rmse_train = mean_squared_error(train_y,predict_train)**(0.5) print('\nRMSE on train dataset : ', rmse_train) # predict the target on the test dataset predict_test = model.predict(test_x) # Accuracy Score on test dataset rmse_test = mean_squared_error(test_y,predict_test)**(0.5) print('\nRMSE on test dataset : ', rmse_test) # create the object of the PCA (Principal Component Analysis) model # reduce the dimensions of the data to 12 ''' You can also add other parameters and test your code here Some parameters are : svd_solver, iterated_power Documentation of sklearn PCA: https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html ''' model_pca = PCA(n_components=12) new_train = model_pca.fit_transform(train_x) new_test = model_pca.fit_transform(test_x) print('\nTraining model with {} dimensions.'.format(new_train.shape[1])) # create object of model model_new = LinearRegression() # fit the model with the training data model_new.fit(new_train,train_y) # predict the target on the new train dataset predict_train_pca = model_new.predict(new_train) # Accuray Score on train dataset rmse_train_pca = mean_squared_error(train_y,predict_train_pca)**(0.5) print('\nRMSE on new train dataset : ', rmse_train_pca) # predict the target on the new test dataset predict_test_pca = model_new.predict(new_test) # Accuracy Score on test dataset rmse_test_pca = mean_squared_error(test_y,predict_test_pca)**(0.5) print('\nRMSE on new test dataset : ', rmse_test_pca) R Code: library(stats) pca <- princomp(train, cor = TRUE) train_reduced <- predict(pca,train) test_reduced <- predict(pca,test) 10. Gradient Boosting Algorithms Now, let’s look at the 4 most commonly used gradient boosting algorithms. GBM GBM is a boosting algorithm used when we deal with plenty of data to make a prediction with high prediction power. Boosting is actually an ensemble of learning algorithms that combines the prediction of several base estimators in order to improve robustness over a single estimator. It combines multiple weak or average predictors to build a strong predictor. These boosting algorithms always work well in data science competitions like Kaggle, AV Hackathon, and CrowdAnalytix. Python Code: # importing required libraries import pandas as pd from sklearn.ensemble import GradientBoostingClassifier from sklearn.metrics import accuracy_score # read the train and test dataset train_data = pd.read_csv('train-data.csv') test_data = pd.read_csv('test-data.csv') # shape of the dataset print('Shape of training data :',train_data.shape) print('Shape of testing data :',test_data.shape) # Now, we need to predict the missing target variable in the test data # target variable - Survived # seperate the independent and target variable on training data train_x = train_data.drop(columns=['Survived'],axis=1) train_y = train_data['Survived'] # seperate the independent and target variable on testing data test_x = test_data.drop(columns=['Survived'],axis=1) test_y = test_data['Survived'] ''' Create the object of the GradientBoosting Classifier model You can also add other parameters and test your code here Some parameters are : learning_rate, n_estimators Documentation of sklearn GradientBoosting Classifier: https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html ''' model = GradientBoostingClassifier(n_estimators=100,max_depth=5) # fit the model with the training data model.fit(train_x,train_y) # predict the target on the train dataset predict_train = model.predict(train_x) print('\nTarget on train data',predict_train) # Accuray Score on train dataset accuracy_train = accuracy_score(train_y,predict_train) print('\naccuracy_score on train dataset : ', accuracy_train) # predict the target on the test dataset predict_test = model.predict(test_x) print('\nTarget on test data',predict_test) # Accuracy Score on test dataset accuracy_test = accuracy_score(test_y,predict_test) print('\naccuracy_score on test dataset : ', accuracy_test) R Code: library(caret) x <- cbind(x_train,y_train) # Fitting model fitControl <- trainControl( method = "repeatedcv", number = 4, repeats = 4) fit <- train(y ~ ., data = x, method = "gbm", trControl = fitControl,verbose = FALSE) predicted= predict(fit,x_test,type= "prob")[,2] GradientBoostingClassifier and Random Forest are two different boosting tree classifiers, and often people ask about the difference between these two algorithms. XGBoost Another classic gradient-boosting algorithm that’s known to be the decisive choice between winning and losing in some Kaggle competitions is the XGBoost. It has an immensely high predictive power, making it the best choice for accuracy in events. It possesses both a linear model and the tree learning algorithm, making the algorithm almost 10x faster than existing gradient booster techniques. One of the most interesting things about the XGBoost is that it is also called a regularized boosting technique. This helps to reduce overfit modeling and has massive support for a range of languages such as Scala, Java, R, Python, Julia, and C++. The support includes various objective functions, including regression, classification, and ranking. Supports distributed and widespread training on many machines that encompass GCE, AWS, Azure, and Yarn clusters. XGBoost can also be integrated with Spark, Flink, and other cloud dataflow systems with built-in cross-validation at each iteration of the boosting process. Python Code: # importing required libraries import pandas as pd from xgboost import XGBClassifier from sklearn.metrics import accuracy_score # read the train and test dataset train_data = pd.read_csv('train-data.csv') test_data = pd.read_csv('test-data.csv') # shape of the dataset print('Shape of training data :',train_data.shape) print('Shape of testing data :',test_data.shape) # Now, we need to predict the missing target variable in the test data # target variable - Survived # seperate the independent and target variable on training data train_x = train_data.drop(columns=['Survived'],axis=1) train_y = train_data['Survived'] # seperate the independent and target variable on testing data test_x = test_data.drop(columns=['Survived'],axis=1) test_y = test_data['Survived'] ''' Create the object of the XGBoost model You can also add other parameters and test your code here Some parameters are : max_depth and n_estimators Documentation of xgboost: https://xgboost.readthedocs.io/en/latest/ ''' model = XGBClassifier() # fit the model with the training data model.fit(train_x,train_y) # predict the target on the train dataset predict_train = model.predict(train_x) print('\nTarget on train data',predict_train) # Accuray Score on train dataset accuracy_train = accuracy_score(train_y,predict_train) print('\naccuracy_score on train dataset : ', accuracy_train) # predict the target on the test dataset predict_test = model.predict(test_x) print('\nTarget on test data',predict_test) # Accuracy Score on test dataset accuracy_test = accuracy_score(test_y,predict_test) print('\naccuracy_score on test dataset : ', accuracy_test) R Code: require(caret) x <- cbind(x_train,y_train) # Fitting model TrainControl <- trainControl( method = "repeatedcv", number = 10, repeats = 4) model<- train(y ~ ., data = x, method = "xgbLinear", trControl = TrainControl,verbose = FALSE) OR model<- train(y ~ ., data = x, method = "xgbTree", trControl = TrainControl,verbose = FALSE) predicted <- predict(model, x_test) LightGBM LightGBM is a gradient-boosting framework that uses tree-based learning algorithms. It is designed to be distributed and efficient with the following advantages: Faster training speed and higher efficiency Lower memory usage Better accuracy Parallel and GPU learning supported Capable of handling large-scale data The framework is a fast and high-performance gradient-boosting one based on decision tree algorithms used for ranking, classification, and many other machine-learning tasks. It was developed under the Distributed Machine Learning Toolkit Project of Microsoft. Since the LightGBM is based on decision tree algorithms, it splits the tree leaf-wise with the best fit, whereas other boosting algorithms split the tree depth-wise or level-wise rather than leaf-wise. So when growing on the same leaf node in Light GBM, the leaf-wise algorithm can reduce more loss than the level-wise algorithm, resulting in much better accuracy, which any existing boosting algorithms can rarely achieve. Also, it is surprisingly very fast, hence the word ‘Light.’ Python Code: data = np.random.rand(500, 10) # 500 entities, each contains 10 features label = np.random.randint(2, size=500) # binary target train_data = lgb.Dataset(data, label=label) test_data = train_data.create_valid('test.svm') param = {'num_leaves':31, 'num_trees':100, 'objective':'binary'} param['metric'] = 'auc' num_round = 10 bst = lgb.train(param, train_data, num_round, valid_sets=[test_data]) bst.save_model('model.txt') # 7 entities, each contains 10 features data = np.random.rand(7, 10) ypred = bst.predict(data) R Code: library(RLightGBM) data(example.binary) #Parameters num_iterations <- 100 config <- list(objective = "binary", metric="binary_logloss,auc", learning_rate = 0.1, num_leaves = 63, tree_learner = "serial", feature_fraction = 0.8, bagging_freq = 5, bagging_fraction = 0.8, min_data_in_leaf = 50, min_sum_hessian_in_leaf = 5.0) #Create data handle and booster handle.data <- lgbm.data.create(x) lgbm.data.setField(handle.data, "label", y) handle.booster <- lgbm.booster.create(handle.data, lapply(config, as.character)) #Train for num_iterations iterations and eval every 5 steps lgbm.booster.train(handle.booster, num_iterations, 5) #Predict pred <- lgbm.booster.predict(handle.booster, x.test) #Test accuracy sum(y.test == (y.pred > 0.5)) / length(y.test) #Save model (can be loaded again via lgbm.booster.load(filename)) lgbm.booster.save(handle.booster, filename = "/tmp/model.txt") If you’re familiar with the Caret package in R, this is another way of implementing the LightGBM. require(caret) require(RLightGBM) data(iris) model <-caretModel.LGBM() fit <- train(Species ~ ., data = iris, method=model, verbosity = 0) print(fit) y.pred <- predict(fit, iris[,1:4]) library(Matrix) model.sparse <- caretModel.LGBM.sparse() #Generate a sparse matrix mat <- Matrix(as.matrix(iris[,1:4]), sparse = T) fit <- train(data.frame(idx = 1:nrow(iris)), iris$Species, method = model.sparse, matrix = mat, verbosity = 0) print(fit) Catboost CatBoost is one of open-sourced machine learning algorithms from Yandex. It can easily integrate with deep learning frameworks like Google’s TensorFlow and Apple’s Core ML. The best part about CatBoost is that it does not require extensive data training like other ML models and can work on a variety of data formats, not undermining how robust it can be. Catboost can automatically deal with categorical variables without showing the type conversion error, which helps you to focus on tuning your model better rather than sorting out trivial errors. Make sure you handle missing data well before you proceed with the implementation. Python Code: import pandas as pd import numpy as np from catboost import CatBoostRegressor #Read training and testing files train = pd.read_csv("train.csv") test = pd.read_csv("test.csv") #Imputing missing values for both train and test train.fillna(-999, inplace=True) test.fillna(-999,inplace=True) #Creating a training set for modeling and validation set to check model performance X = train.drop(['Item_Outlet_Sales'], axis=1) y = train.Item_Outlet_Sales from sklearn.model_selection import train_test_split X_train, X_validation, y_train, y_validation = train_test_split(X, y, train_size=0.7, random_state=1234) categorical_features_indices = np.where(X.dtypes != np.float)[0] #importing library and building model from catboost import CatBoostRegressormodel=CatBoostRegressor(iterations=50, depth=3, learning_rate=0.1, loss_function='RMSE') model.fit(X_train, y_train,cat_features=categorical_features_indices,eval_set=(X_validation, y_validation),plot=True) submission = pd.DataFrame() submission['Item_Identifier'] = test['Item_Identifier'] submission['Outlet_Identifier'] = test['Outlet_Identifier'] submission['Item_Outlet_Sales'] = model.predict(test) R Code: set.seed(1) require(titanic) require(caret) require(catboost) tt <- titanic::titanic_train[complete.cases(titanic::titanic_train),] data <- as.data.frame(as.matrix(tt), stringsAsFactors = TRUE) drop_columns = c("PassengerId", "Survived", "Name", "Ticket", "Cabin") x <- data[,!(names(data) %in% drop_columns)]y <- data[,c("Survived")] fit_control <- trainControl(method = "cv", number = 4,classProbs = TRUE) grid <- expand.grid(depth = c(4, 6, 8),learning_rate = 0.1,iterations = 100, l2_leaf_reg = 1e-3, rsm = 0.95, border_count = 64) report <- train(x, as.factor(make.names(y)),method = catboost.caret,verbose = TRUE, preProc = NULL,tuneGrid = grid, trControl = fit_control) print(report) importance <- varImp(report, scale = FALSE) print(importance) Practice Problems Now, it’s time to take the plunge and actually play with some other real-world datasets. So are you ready to take on the challenge? Accelerate your data science journey with the following practice problems: Practice Problem: Food Demand Forecasting ChallengePredict the demand for meals for a meal delivery companyPractice Problem: HR Analytics ChallengeIdentify the employees most likely to get promotedPractice Problem: Predict Number of UpvotesPredict the number of upvotes on a query asked at an online question & answer platform Conclusion By now, I am sure you would have an idea of commonly used machine learning algorithms. My sole intention behind writing this article and providing the codes in R and Python is to get you started right away. If you are keen to master machine learning algorithms, start right away. Take up problems, develop a physical understanding of the process, apply these codes, and watch the fun! Hope you like the article and get full understanding about the data science algoeitrhms, machine learning models and with these you will get full understanding about machine learning algorithms. If you found this article helpful and want to master your machine learning skills, Enroll in our AI/ML Blackbelt Plus Program today! Key Takeaways We are now familiar with some of the most common ML algorithms used in the industry. We’ve covered the advantages and disadvantages of various ML algorithms. We’ve also learned the basic implementation details in R and Python languages. Frequently Asked Questions Q1. Which algorithm is mostly used in machine learning? A. While the suitable algorithm depends on the problem you are trying to solve. Q2. What is the difference between supervised and unsupervised ML? A. In the supervised learning model, the labels associated with the features are given. In unsupervised learning, no labels are provided for the model. Q3. What are the main 3 types of ML models? A. The 3 main types of ML models are based on Supervised Learning, Unsupervised Learning, and Reinforcement Learning. Q4. What is an algorithm in machine learning? A. An algorithm in machine learning is a set of rules or procedures that a model follows to learn from data. It processes input data, identifies patterns, and makes predictions or decisions based on that data, enabling computers to improve over time without explicit programming. Q5. How to apply ML algorithms? A. To apply machine learning algorithms, first, define the problem and collect relevant data. Preprocess the data (cleaning, normalization), choose an appropriate algorithm based on the task (classification, regression, etc.), train the model on the dataset, and finally evaluate its performance using metrics like accuracy or F1-score. Q6. Is CNN a machine learning algorithm? A. Yes, a Convolutional Neural Network (CNN) is a deep learning algorithm designed for image and video recognition, using convolutional layers to automatically extract features and enhance visual data processing. Sunil Ray Sunil Ray is Chief Content Officer at Analytics Vidhya, India's largest Analytics community. I am deeply passionate about understanding and explaining concepts from first principles. In my current role, I am responsible for creating top notch content for Analytics Vidhya including its courses, conferences, blogs and Competitions. I thrive in fast paced environment and love building and scaling products which unleash huge value for customers using data and technology. Over the last 6 years, I have built the content team and created multiple data products at Analytics Vidhya. Prior to Analytics Vidhya, I have 7+ years of experience working with several insurance companies like Max Life, Max Bupa, Birla Sun Life & Aviva Life Insurance in different data roles. Industry exposure: Insurance, and EdTech Major capabilities: Content Development, Product Management, Analytics, Growth Strategy. AlgorithmBest of TechIntermediateListicleMachine Learning Login to continue reading and enjoy expert-curated content. Keep Reading for Free Free Courses 4.7 Generative AI - A Way of Life Explore Generative AI for beginners: create text and images, use top AI tools, learn practical skills, and ethics. 4.5 Getting Started with Large Language Models Master Large Language Models (LLMs) with this course, offering clear guidance in NLP and model training made simple. 4.6 Building LLM Applications using Prompt Engineering This free course guides you on building LLM apps, mastering prompt engineering, and developing chatbots with enterprise data. 4.8 Improving Real World RAG Systems: Key Challenges & Practical Solutions Explore practical solutions, advanced retrieval strategies, and agentic RAG systems to improve context, relevance, and accuracy in AI-driven applications. 4.7 Microsoft Excel: Formulas & Functions Master MS Excel for data analysis with key formulas, functions, and LookUp tools in this comprehensive course. Recommended ArticlesA Comprehensive Guide to Ensemble Learning (wit...Top 12 Dimensionality Reduction TechniquesPrincipal Component Analysis & its Impleme...Principal Component Analysis Introduction and P...Beginners Guide To Learn Dimension Reduction Te...20 Questions to Test Your Skills On Dimensional...Principal Component Analysis in Machine Learnin...Titanic Survival Prediction Using Machine LearningBuilding A Gold Price Prediction Model Using Ma... Responses From Readers Cancel reply ClearSubmit reply Δ Kuber Awesowe compilation!! Thank you. 123 Cancel reply ClearSubmit reply Δ Karthikeyan Thank you very much, A Very useful and excellent compilation. I have already bookmarked this page. 123 Cancel reply ClearSubmit reply Δ hemanth Straight, Informative and effective!! Thank you 123 Cancel reply ClearSubmit reply Δ View All Become an Author Share insights, grow your voice, and inspire the data community. Reach a Global Audience Share Your Expertise with the World Build Your Brand & Audience Join a Thriving AI Community Level Up Your AI Game Expand Your Influence in Genrative AI Flagship Programs GenAI Pinnacle Program| GenAI Pinnacle Plus Program| AI/ML BlackBelt Program| Agentic AI Pioneer Program Free Courses Generative AI| DeepSeek| OpenAI Agent SDK| LLM Applications using Prompt Engineering| DeepSeek from Scratch| Stability.AI| SSM & MAMBA| RAG Systems using LlamaIndex| Building LLMs for Code| Python| Microsoft Excel| Machine Learning| Deep Learning| Mastering Multimodal RAG| Introduction to Transformer Model| Bagging & Boosting| Loan Prediction| Time Series Forecasting| Tableau| Business Analytics| Vibe Coding in Windsurf| Model Deployment using FastAPI| Building Data Analyst AI Agent| Getting started with OpenAI o3-mini| Introduction to Transformers and Attention Mechanisms Popular Categories AI Agents| Generative AI| Prompt Engineering| Generative AI Application| News| Technical Guides| AI Tools| Interview Preparation| Research Papers| Success Stories| Quiz| Use Cases| Listicles Generative AI Tools and Techniques GANs| VAEs| Transformers| StyleGAN| Pix2Pix| Autoencoders| GPT| BERT| Word2Vec| LSTM| Attention Mechanisms| Diffusion Models| LLMs| SLMs| Encoder Decoder Models| Prompt Engineering| LangChain| LlamaIndex| RAG| Fine-tuning| LangChain AI Agent| Multimodal Models| RNNs| DCGAN| ProGAN| Text-to-Image Models| DDPM| Document Question Answering| Imagen| T5 (Text-to-Text Transfer Transformer)| Seq2seq Models| WaveNet| Attention Is All You Need (Transformer Architecture) | WindSurf| Cursor Popular GenAI Models Llama 4| Llama 3.1| GPT 4.5| GPT 4.1| GPT 4o| o3-mini| Sora| DeepSeek R1| DeepSeek V3| Janus Pro| Veo 2| Gemini 2.5 Pro| Gemini 2.0| Gemma 3| Claude Sonnet 3.7| Claude 3.5 Sonnet| Phi 4| Phi 3.5| Mistral Small 3.1| Mistral NeMo| Mistral-7b| Bedrock| Vertex AI| Qwen QwQ 32B| Qwen 2| Qwen 2.5 VL| Qwen Chat| Grok 3 AI Development Frameworks n8n| LangChain| Agent SDK| A2A by Google| SmolAgents| LangGraph| CrewAI| Agno| LangFlow| AutoGen| LlamaIndex| Swarm| AutoGPT Data Science Tools and Techniques Python| R| SQL| Jupyter Notebooks| TensorFlow| Scikit-learn| PyTorch| Tableau| Apache Spark| Matplotlib| Seaborn| Pandas| Hadoop| Docker| Git| Keras| Apache Kafka| AWS| NLP| Random Forest| Computer Vision| Data Visualization| Data Exploration| Big Data| Common Machine Learning Algorithms| Machine Learning| Google Data Science Agent Company About Us Contact Us Careers Discover Blogs Expert Sessions Learning Paths Comprehensive Guides Learn Free Courses AI&ML Program Pinnacle Plus Program Agentic AI Program Engage Community Hackathons Events Podcasts Contribute Become an Author Become a Speaker Become a Mentor Become an Instructor Enterprise Our Offerings Trainings Data Culture AI Newsletter Terms & conditions Refund Policy Privacy Policy Cookies Policy © Analytics Vidhya 2025.All rights reserved. SKIP Continue your learning for FREE Login with Google Login with Email Forgot your password? I accept the Terms and Conditions Receive updates on WhatsApp Enter email address to continue Email address Get OTP Enter OTP sent to Edit Wrong OTP. Enter the OTP Resend OTP Resend OTP in 45s Verify OTP